## 35. Search Insert Position
#### 1. 문제 파악
- 정렬된 숫자 배열에서 해당 숫자를 찾아 해당 인덱스를 반환한다.
- 만약 없다면, 순서대로 삽입되었을 경우의 인덱스를 반환한다.
- 시간 복잡도는 `O(logn)`
#### 2. 재정의와 추상화
#### 3. 계획 세우기
- 시간 복잡도가 `O(logn)` 이고 정렬된 배열이라면 이진 탐색을 사용한다.
- 왼쪽, 오른쪽 포인터를 잡고 중앙값 기준으로 탐색한다.
  - 중앙값이 target 보다 크면, 중앙값 - 1을 오른쪽으로 할당하고 탐색한다.
  - 중앙값이 target 보다 작으면, 중앙값 + 1을 왼쪽으로 할당하고 탐색한다.
- 해당 탐색을 모두 마쳤다면 즉, 왼쪽이 오른쪽 포인터와 크다면 왼쪽을 반환한다.
#### 4. 검증하기
#### 5. 계획 수행하기
- 코딩 실행

### 6. 회고
- 중앙값을 구할 때 단순히 `(right + left) / 2`를 하지 않는 이유는 더했을 경우 숫자범위가 할당 메모리보다 클 수도 있기 때문
```javascript
const mid = Math.floor(left + (right - left) / 2);
```
