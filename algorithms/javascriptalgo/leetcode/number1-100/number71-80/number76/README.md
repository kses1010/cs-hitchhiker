## 76. Minimum Window Substring
#### 1. 문제 파악
- 각각 길이가 m과 n인 두 개의 문자열 s와 t가 주어지면 
- t의 모든 문자(중복 포함)가 윈도우에 포함되도록 s의 최소 윈도우 하위 문자열 을 반환합니다. 
- 그러한 하위 문자열이 없으면 빈 문자열 ""을 반환합니다. 
- 테스트 케이스는 답이 고유하도록 생성됩니다.
#### 2. 재정의와 추상화
#### 3. 계획 세우기
- 우선적으로 s의 길이가 t의 길이보다 작다면 빈값("")을 리턴한다.
- 문자열 t의 문자별 빈도수를 찾기 위해 객체를 생성하고 빈도 수를 체크한다.
  - `tMap[c] = (tMap[c] || 0) + 1`
- t의 고유 문자 개수를 기억하여 현재 윈도우안에 있는 문자열이 해당 개수를 만족시키는지 확인한다.
- 왼쪽, 오른쪽, 윈도우 내 t의 문자 만족하는 문자의 수를 0으로 할당한다. (left, right, satisfy)
- 윈도우 내 문자별 빈도수를 나타내는 windowCounts 라는 이름으로 객체를 생성한다.
- 윈도우를 기록하는 윈도우를 만든다. (`[윈도우길이(Infinity), 왼쪽, 오른쪽]`)
- while 문으로 오른쪽 인덱스가 s의 길이보다 작을때까지
  - 오른쪽 문자열을 뽑고(`s[right]`)
  - windowCounts 객체에 카운팅
  - 만약 tMap에 해당 문자가 있고, windowCounts 와 tMap 의 문자 빈도수가 같다면 satisfy + 1을 한다.
  - 빈도수가 다 만족했으니 right + 1 을 하여 오른쪽 포인터를 이동시킨다.
- 오른쪽 포인터를 옮기기 전에 왼쪽 포인터도 옮길만한 조건이 맞는지 확인해야하는데
- while 문으로 왼쪽 <= 오른쪽 이면서 윈도우 내 만족 문자수(satisfy)와 고유 문자 개수(required)가 같을 동안
  - 왼쪽 문자열을 뽑고(`s[left]`)
  - 갱신된 윈도우의 길이가 현재 윈도우보다 짧으면 윈도우를 갱신한다. (`[right - left + 1, left, right]`)
  - 왼쪽 포인터를 옮겼으므로(`left++`) windowCounts 에서 왼쪽 문자열의 갯수를 -1을 한다.
  - 만약 tMap에 해당 문자가 있고, windowCounts < tMap 이라면
  - 즉, 윈도우를 줄였는데 만족하는 문자열의 수가 적어진다면 satisfy -1 을 한다.
- while 문을 마치고 난 뒤 `window[0]` 윈도우 길이를 기준으로 해당 문자열을 잘라 리턴한다.
- 즉, 윈도우의 길이가 Infinity 라면 윈도우가 갱신되지 않았으므로 ""
- 아니라면 `s.subString(window[1], window[2] + 1)`을 리턴한다.
#### 4. 검증하기
#### 5. 계획 수행하기
- 코딩 실행

### 6. 회고

