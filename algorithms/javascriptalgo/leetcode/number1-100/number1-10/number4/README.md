## 4. Median of Two Sorted Arrays
#### 1. 문제 파악
- 각각 크기가 m과 n인 두 개의 정렬된 배열 nums1과 nums2가 주어졌을 때, 두 정렬된 배열의 중앙값을 반환합니다.
- 시간 복잡도는 `O(log(m+n))`이어야 합니다.
#### 2. 재정의와 추상화
#### 3. 계획 세우기
- 요구사항의 시간 복잡도는 `O(log(m+n))` 이므로 투 포인터가 아닌 이분(이진) 탐색으로 풀어야 한다.
- `if (nums1.length > nums2.length)` 조건을 통해 항상 짧은 배열에 대해 이분 탐색을 진행하도록 한다.
- 분할 인덱스를 계산하는데 각 번호는 nums1, nums2 를 의미한다.
  - partition1 은 nums1 에서 선택한 분할 위치다.
  - partition2 은 `(m+n+1)/2 - partition1` 두 배열의 왼쪽 부분에 전체 원소의 절반(혹은 절반+1)이 오도록 한다.
- 각 분할의 경계값을 설정한다.
  - partition1나 partition2가 0이면 해당 배열의 왼쪽 값은 없으므로 `-Infinity`로 처리한다.
  - 반대로, 분할 인덱스가 배열의 길이와 같으면 오른쪽 값이 없으므로 `Infinity`로 처리한다.
- 분할 조건 검사를 한다.
  - 왼쪽 부분의 최대값(maxLeft1, maxLeft2)이 오른쪽 부분의 최소값(minRight1, minRight2)보다 작거나 같아야 한다.
  - 이 조건이 만족되면 올바른 분할점에 도달한 것이며, 
    - 전체 길이가 홀수이면 왼쪽 부분의 최대값이 중앙값, 
    - 짝수이면 왼쪽 최대값과 오른쪽 최소값의 평균을 반환한다.
- 이분 탐색 조정하기
  - 만약 maxLeft1 > minRight2라면, nums1의 왼쪽 부분에 너무 많은 원소가 포함되어 있으므로, 분할 인덱스를 줄여야 한다. 
  - 반대로 maxLeft2 > minRight1면, 분할 인덱스를 늘린다.
#### 4. 검증하기
#### 5. 계획 수행하기
- 코딩 실행

### 6. 회고
