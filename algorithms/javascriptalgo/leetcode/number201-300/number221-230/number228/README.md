## 228. Summary Ranges
#### 1. 문제 파악
- 중복되지 않는 오름차순으로 정렬된 배열 `nums`가 있다.
- 각 지정된 배열내에 가장 작으면서 정렬된 범위를 반환할 것.
- 즉, `nums`의 각 요소는 정확히 하나의 범위에 포함되며, `x`가 범위 중 하나에 속하지만 `nums`에는 속하지 않는 정수 x는 없다.
- 예시는 다음과 같다.
  - `a != b` 면 "a -> b"
  - `a == b` 면 "a"
#### 2. 재정의와 추상화
#### 3. 계획 세우기
- 인덱스 시작점 `start`를 0으로 선언
- for loop 를 돌면서 지금 인덱스와 이전 인덱스와의 차이가 1이거나 현재 `i`가 `nums`의 길이보다 적을 경우 통과
- 해당 조건을 만족하지 않는 지금 인덱스와 이전 인덱스와의 차이가 1이 아닐 경우
  - 인덱스 시작점 요소(`nums[start]`)와 이전 인덱스 요소(`nums[i - 1]`)이 일치하지 않으면 `nums[start]->nums[i - 1]` 처리
  - 아니면 그대로 그 값 처리 `nums[i - 1]`
  - 처리했다면 start 는 현재 인덱스 할당 `start = i`

#### 4. 검증하기
#### 5. 계획 수행하기
- 코딩 실행

### 6. 회고
