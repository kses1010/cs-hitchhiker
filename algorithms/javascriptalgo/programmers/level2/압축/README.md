## 압축
#### 1. 문제 파악
- LZW 압축은 다음 과정을 거친다.
  1. 길이가 1인 모든 단어를 포함하도록 사전을 초기화한다. 
  2. 사전에서 현재 입력과 일치하는 가장 긴 문자열 w를 찾는다. 
  3. w에 해당하는 사전의 색인 번호를 출력하고, 입력에서 w를 제거한다. 
  4. 입력에서 처리되지 않은 다음 글자가 남아있다면(c), w+c에 해당하는 단어를 사전에 등록한다. 
  5. 단계 2로 돌아간다.
- 압축 알고리즘은 영문 대문자로 처리한다면 색인번호는 다음 정수값으로 준다.
```
1: A, 2: B, 3: C, ... 24: X, 25: Y, 26: Z
```
- 만약 `KAKAO` 라는 글자가 왔을 경우
  1. 현재 사전에는 KAKAO의 첫 글자 K는 등록되어 있으나, 두 번째 글자까지인 KA는 없으므로, 첫 글자 K에 해당하는 색인 번호 11을 출력하고, 다음 글자인 A를 포함한 KA를 사전에 27 번째로 등록한다.
  2. 두 번째 글자 A는 사전에 있으나, 세 번째 글자까지인 AK는 사전에 없으므로, A의 색인 번호 1을 출력하고, AK를 사전에 28 번째로 등록한다.
  3. 세 번째 글자에서 시작하는 KA가 사전에 있으므로, KA에 해당하는 색인 번호 27을 출력하고, 다음 글자 O를 포함한 KAO를 29 번째로 등록한다. 
  4. 마지막으로 처리되지 않은 글자 O에 해당하는 색인 번호 15를 출력한다.
- 해당 색인 번호는 `[11, 1, 27, 15]`를 리턴한다.
- 주어진 문자열 `msg`가 주어졌을 때 압축한 후의 사전 색인 번호를 배열로 리턴할 것.
  - `msg`의 길이는 1글자 이상, 1000 글자 이하다.
#### 2. 재정의와 추상화
#### 3. 계획 세우기
- 우선적으로 객체나 Map 을 활용하여 A ~ Z 까지 각 문자에 해당하는 번호를 부여한다.(`dict`)
- 다음 문자(`nextWord`)를 빈값으로 / 다음 문자열에 해당하나는 숫자 27로 초기화한다. (`nextWord = "" / wordNumber = 27`)
- `msg`문자열을 받아 split 하고 reduce 콜백 함수를 활용하여 진행한다. 여기서 사용될 파라미터는 `acc, cur`만 사용한다.
  - `nextWord` 는 `acc + cur` 하여 다음 문자를 생성한다.
  - 만약 `dict`에 해당 `nextWord`가 없을 경우 즉, `undefined` 상태라면 `wordNumber++` 하여 넣어준다.
    - 있을 경우에는 누적된 문자를 그대로 리턴한다.
  - 만약 사전에 누적된 문자값이 존재할경우에 answer 배열에 해당 문자 사전번호를 푸시한다.
  - 여기까지 진행되었다면 그대로 현재 값을 리턴한다.
- 모두 마무리 되었다면 answer 배열에 사전의 지금 문자 번호를 푸시한다.
#### 4. 검증하기
#### 5. 계획 수행하기
- 코딩 실행

### 6. 회고
