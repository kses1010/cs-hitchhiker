## 롤케이크 자르기
#### 1. 문제 파악
- 토핑의 개수에 상관없이 각 조각에 동일한 가짓수의 토핑이 올라가면 공평하게 롤케이크가 나누어진 것으로 생각합니다.
- 토핑들을 1, 2, 3, 4와 같이 번호로 표시했을 때, 케이크 위에 토핑들이 [1, 2, 1, 3, 1, 4, 1, 2] 순서로 올려져 있습니다.
- 만약 컷팅을 [1, 2, 1] / [3, 1, 4, 1, 2] 로 진행한다면 한사람은 2가지(1, 2) 또다른 사람은 (1, 2, 3, 4)토핑을 맛볼 수 있어 불공평
- 만약 컷팅을 [1, 2, 1, 3] / [1, 4, 1, 2] 로 진행한다면 둘다 공평하게 3가지씩(1, 2, 3) / (1, 4, 2)로 맛볼 수 있음
- [1, 2, 1, 3, 1] / [4, 1, 2]으로 잘라도 공평하게 나뉜다.
- 다음 토핑 배열 topping이 주어졌을 때 공평하게 자르는 방법의 갯수를 리턴하는 함수 만들기

제한사항
- 1 ≤ topping의 길이 ≤ 1,000,000
- 1 ≤ topping의 원소 ≤ 10,000
#### 2. 재정의와 추상화
#### 3. 계획 세우기
- 방법 1. 인덱스마다 잘라서 비교하는 방법이 있다.
  - for 문으로 각 인덱스마다 잘라서 set을 활용하여 토핑의 종류를 확인하고 비교하여 일치할 경우 +1을 하는 방식
  - 다만 토핑의 길이가 1,000,000 이라 시간 복잡도에서 걸릴 가능성이 높다.
- 방법 2. 토핑의 종류마다 카운팅하고 왼쪽에 모두 몰아 넣은 다음에 오른쪽으로 하나씩 옮기기
  - 왼쪽 조각, 오른쪽 조각의 토핑 종류를 체크하는 set 초기화
  - 토핑 종류마다 갯수를 확인하는 `toppingCount` 배열을 추가하는데 토핑의 종류가 1 ~ 10000 이므로 10001개를 0으로 체운다.
  - 먼저 토핑을 전부 왼쪽 조각에 몰아 넣으면서 토핑별 갯수를 추가한다.
  - 다시 토핑배열을 돌면서 확인한다.
    - 만약 토핑이 `toppingCount`에서 0 초과일경우 즉, 왼쪽 조각에 토핑이 아직 남아 있다면 해당 topping의 갯수를 -1 한다.
    - 만약 토핑이 `toppingCount`에서 0 일 경우 즉, 왼쪽 조각에 토핑이 없다면 해당 토픽을 제거한다.(`left.delete(t)`)
    - 다 지나고 난뒤 오른쪽에 해당 토픽을 추가한다. (`right.add(t)`)
    - 그 뒤에 왼쪽의 갯수와 오른쪽의 갯수가 일치한다면 answer + 1을 한다.
#### 4. 검증하기
#### 5. 계획 수행하기
- 코딩 실행

### 6. 회고
- 메모이제이션을 활용하여 풀이를 했다. topping의 종류마다 카운팅을 하여 진행
- 토핑 카운팅 배열에서 해당 토핑마다 확인하는 행동은 왼쪽 조각에서 오른쪽 조각으로 옮기는 행동이라고 생각하면 된다.
