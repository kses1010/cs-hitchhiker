## 단어 변환
#### 1. 문제 파악
- begin, target과 단어의 집합 words가 있습니다. 
- 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다.
```
1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다.
2. words에 있는 단어로만 변환할 수 있습니다.
```
- begin이 `"hit"`, target가 `"cog"`, words가 `["hot","dot","dog","lot","log","cog"]`라면 
- "hit" -> "hot" -> "dot" -> "dog" -> "cog"와 같이 4단계를 거쳐 변환할 수 있습니다.
- 최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수 작성하기
- 제한사항
  - 각 단어는 알파벳 소문자로만 이루어져 있습니다. 
  - 각 단어의 길이는 3 이상 10 이하이며 모든 단어의 길이는 같습니다. 
  - words에는 3개 이상 50개 이하의 단어가 있으며 중복되는 단어는 없습니다. 
  - begin과 target은 같지 않습니다.
  - 변환할 수 없는 경우에는 0를 return 합니다.
#### 2. 재정의와 추상화
#### 3. 계획 세우기
- 먼저 시작하기 앞서 words 에 해당 target 단어가 없다면 그대로 0을 리턴한다.
- 트리구조로 탐색하면서 최소한의 층을 기록하면서 진행한다. 최소한의 층 탐색은 BFS로 탐색한다.
- 방문 배열을 만들어 중복 방문을 방지한다.
- 큐를 만드는데 현재 단어와 현재까지의 변환 단계를 함께 저장하도록 한다. (`[begin, 0]`)
- 한 글자만 다른 단어인지 체크하는 함수
  - 차이 카운트 diff 를 0으로 초기화
  - 매개변수 word1, word2 를 받는다.
  - for 문을 word1 의 길이만큼 돌면서 word1, word2 의 문자열이 다르다면 diff + 1을 한다.
  - diff 가 1인지 아닌지를 boolean 값으로 리턴한다.
- while 문으로 큐가 비워져 있지 않을 때까지 실행하는데
  - shift로 뽑아 각 word, count로 할당한다.
  - 만약 word 가 target과 같다면 그대로 count 를 리턴한다.
  - for 문을 words 길이만큼 돌면서
    - 만약 아직 방문하지 않았고, 한 글자만 다른 단어라면 큐에 추가한다. -> 한 글자만 다른 단어인지 체크하는 함수를 만든다.
    - 통과한다면 해당 단어는 방문했다는 표시로 true 처리하고, 큐에 해당 단어와 count + 1을 한다.
- BFS로 전부 탐색했으나 못찾았다면 0을 리턴한다.
#### 4. 검증하기
#### 5. 계획 수행하기
- 코딩 실행

### 6. 회고
